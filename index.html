<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Venturing Function Dynamics</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #2d2d2d;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.5);
        }
        h1 {
            color: #e0e0e0;
            margin-bottom: 10px;
            font-size: clamp(20px, 4vw, 28px);
        }
        .subtitle {
            color: #a0a0a0;
            margin-bottom: 10px;
            font-style: italic;
            font-size: clamp(12px, 2.5vw, 14px);
        }
        .about-toggle {
            display: inline-block;
            font-size: 12px;
            color: #707070;
            cursor: pointer;
            user-select: none;
            margin-bottom: 20px;
            transition: color 0.2s;
        }
        .about-toggle:hover {
            color: #a0a0a0;
        }
        .about-toggle .toggle-arrow {
            display: inline-block;
            font-size: 10px;
            transition: transform 0.2s;
            margin-right: 4px;
        }
        .about-toggle.open .toggle-arrow {
            transform: rotate(90deg);
        }
        .about-content {
            display: none;
            margin-bottom: 25px;
            padding: 16px 20px;
            background: #232323;
            border-left: 3px solid #404040;
            border-radius: 0 6px 6px 0;
            font-size: 13px;
            line-height: 1.7;
            color: #b0b0b0;
        }
        .about-content.open {
            display: block;
        }
        .about-content h3 {
            color: #d0d0d0;
            font-size: 14px;
            margin: 14px 0 6px 0;
        }
        .about-content h3:first-child {
            margin-top: 0;
        }
        .about-content ul {
            margin: 4px 0;
            padding-left: 18px;
        }
        .about-content li {
            margin: 3px 0;
        }
        .level-section {
            margin-bottom: 40px;
            padding: 20px;
            border: 2px solid #404040;
            border-radius: 8px;
            background: #252525;
        }
        .level-title {
            font-size: clamp(16px, 3vw, 18px);
            font-weight: bold;
            color: #f0f0f0;
            margin-bottom: 15px;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 15px;
            }
            .level-section {
                padding: 15px;
            }
        }
        .visualization {
            display: flex;
            align-items: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .set-display {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            padding: 10px;
            background: #1a1a1a;
            border-radius: 4px;
            min-width: 200px;
            border: 1px solid #404040;
            max-width: 100%;
            overflow-x: auto;
        }
        .fuzzy-bit {
            display: inline-block;
            width: 25px;
            height: 25px;
            margin: 2px;
            text-align: center;
            line-height: 25px;
            border-radius: 3px;
            font-size: 11px;
        }
        .crisp-bit {
            display: inline-block;
            width: 25px;
            height: 25px;
            margin: 2px;
            text-align: center;
            line-height: 25px;
            border-radius: 3px;
            font-weight: bold;
        }
        .bit-0 {
            background: #404040;
            color: #a0a0a0;
        }
        .bit-1 {
            background: #3498db;
            color: white;
        }
        .arrow {
            font-size: 24px;
            color: #808080;
        }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 4px;
            border: 1px solid #404040;
        }
        .controls h4 {
            margin-top: 15px;
            margin-bottom: 10px;
            color: #e0e0e0;
            font-size: clamp(14px, 2.5vw, 16px);
        }
        .control-group {
            margin: 10px 0;
            color: #e0e0e0;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
        }
        .control-group label {
            flex: 1 1 150px;
            min-width: 150px;
            font-weight: 500;
            font-size: clamp(12px, 2vw, 14px);
        }
        .control-group input[type="range"] {
            flex: 1 1 150px;
            min-width: 150px;
        }
        .control-group input[type="number"] {
            width: 60px;
            background: #404040;
            border: 1px solid #606060;
            color: #e0e0e0;
            padding: 4px;
            border-radius: 3px;
        }
        .control-group span {
            min-width: 60px;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: clamp(12px, 2vw, 14px);
            margin: 5px;
            white-space: nowrap;
        }
        button:hover {
            background: #2980b9;
        }
        button:disabled {
            background: #505050;
            cursor: not-allowed;
        }
        
        @media (max-width: 768px) {
            .visualization {
                gap: 10px;
            }
            .arrow {
                font-size: 20px;
                width: 100%;
                text-align: center;
            }
            .set-display {
                min-width: 100%;
                font-size: 12px;
            }
            .fuzzy-bit, .crisp-bit {
                width: 20px;
                height: 20px;
                line-height: 20px;
                font-size: 9px;
                margin: 1px;
            }
            .control-group {
                flex-direction: column;
                align-items: flex-start;
            }
            .control-group label {
                width: 100%;
            }
            .control-group input[type="range"] {
                width: 100%;
            }
            button {
                width: 100%;
                margin: 5px 0;
            }
        }
        .environment-display {
            margin: 20px 0;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 4px;
            border: 1px solid #404040;
            overflow-x: auto;
        }
        .environment-row {
            margin: 5px 0;
            font-family: 'Courier New', monospace;
            white-space: nowrap;
        }
        .concept-window {
            position: relative;
            display: inline-block;
        }
        .window-highlight {
            position: absolute;
            border: 2px solid #e67e22;
            background: rgba(230, 126, 34, 0.1);
            pointer-events: none;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .stat-card {
            padding: 15px;
            background: #1a1a1a;
            border-radius: 4px;
            border: 1px solid #404040;
        }
        .stat-label {
            font-size: clamp(11px, 2vw, 12px);
            color: #a0a0a0;
            margin-bottom: 5px;
        }
        .stat-value {
            font-size: clamp(18px, 4vw, 24px);
            font-weight: bold;
            color: #e0e0e0;
        }
        .outcome-success {
            background: #27ae60;
            color: white;
            border-color: #27ae60;
        }
        .outcome-failure {
            background: #c0392b;
            color: white;
            border-color: #c0392b;
        }
        .outcome-abandoned {
            background: #7f8c8d;
            color: white;
            border-color: #7f8c8d;
        }
        .outcome-burned-out {
            background: #8e44ad;
            color: white;
            border-color: #8e44ad;
        }
        .outcome-running {
            background: #f39c12;
            color: white;
            border-color: #f39c12;
        }
        .cohort-progress-container {
            width: 100%;
            height: 24px;
            background: #1a1a1a;
            border: 1px solid #404040;
            border-radius: 4px;
            margin: 15px 0;
            overflow: hidden;
            display: none;
        }
        .cohort-progress-bar {
            height: 100%;
            width: 0%;
            background: #3498db;
            border-radius: 3px;
            transition: width 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            font-weight: bold;
            min-width: 40px;
        }
        canvas {
            border: 1px solid #404040;
            border-radius: 4px;
            margin: 20px 0;
            background: #1a1a1a;
            max-width: 100%;
            height: auto;
        }
        .scheme-template {
            display: flex;
            gap: 5px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        .scheme-slot {
            width: 30px;
            height: 30px;
            border: 2px dashed #606060;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #a0a0a0;
            background: #2d2d2d;
        }
        .scheme-slot.filled {
            border: 2px solid #16a085;
            background: #16a085;
            color: white;
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .stats {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                gap: 10px;
            }
            .environment-display {
                padding: 10px;
            }
            .scheme-slot {
                width: 25px;
                height: 25px;
                font-size: 10px;
            }
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            border-bottom: 2px solid #404040;
            padding-bottom: 0;
            flex-wrap: wrap;
        }
        .tab-btn {
            background: #1a1a1a;
            color: #a0a0a0;
            border: 2px solid #404040;
            border-bottom: none;
            padding: 12px 24px;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: -2px;
            transition: all 0.2s;
        }
        .tab-btn:hover {
            background: #2d2d2d;
            color: #e0e0e0;
        }
        .tab-btn.active {
            background: #2d2d2d;
            color: #3498db;
            border-color: #3498db;
            border-bottom: 2px solid #2d2d2d;
        }
        .tab-content {
            position: relative;
        }
        .tab-pane {
            display: none;
        }
        .tab-pane.active {
            display: block;
        }

        /* Tornado Chart */
        .tornado-container {
            margin: 20px 0;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 4px;
            border: 1px solid #404040;
        }
        .tornado-row {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 13px;
        }
        .tornado-label {
            width: 140px;
            text-align: right;
            padding-right: 10px;
            color: #a0a0a0;
            flex-shrink: 0;
        }
        .tornado-bar-container {
            flex: 1;
            display: flex;
            align-items: center;
            height: 24px;
            position: relative;
        }
        .tornado-center-line {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #606060;
        }
        .tornado-bar {
            height: 20px;
            position: absolute;
            top: 2px;
            border-radius: 3px;
        }
        .tornado-bar.low {
            background: #3498db;
        }
        .tornado-bar.high {
            background: #e67e22;
        }
        .tornado-value {
            width: 60px;
            text-align: left;
            padding-left: 10px;
            color: #808080;
            font-size: 11px;
            flex-shrink: 0;
        }
        .tornado-legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 15px;
            font-size: 12px;
            color: #a0a0a0;
        }
        .tornado-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .tornado-legend-box {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        /* Experimentation Table */
        .experiment-table-container {
            margin: 20px 0;
            overflow-x: auto;
        }
        .experiment-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        .experiment-table th,
        .experiment-table td {
            padding: 10px 12px;
            text-align: left;
            border: 1px solid #404040;
        }
        .experiment-table th {
            background: #1a1a1a;
            color: #e0e0e0;
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
        }
        .experiment-table th:hover {
            background: #252525;
        }
        .experiment-table th .sort-indicator {
            margin-left: 5px;
            color: #606060;
        }
        .experiment-table th.sorted .sort-indicator {
            color: #3498db;
        }
        .experiment-table td {
            background: #252525;
            color: #c0c0c0;
        }
        .experiment-table tr:hover td {
            background: #2d2d2d;
        }

        /* Parameter Checkboxes */
        .param-selection {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        .param-checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #404040;
            border-radius: 4px;
        }
        .param-checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            color: #e0e0e0;
            font-size: 13px;
        }
        .param-checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        .param-range-inputs {
            display: none;
            gap: 8px;
            margin-top: 8px;
            flex-wrap: wrap;
        }
        .param-checkbox-group.selected .param-range-inputs {
            display: flex;
        }
        .param-range-inputs label {
            font-size: 11px;
            color: #808080;
        }
        .param-range-inputs input[type="number"] {
            width: 60px;
            background: #2d2d2d;
            border: 1px solid #505050;
            color: #e0e0e0;
            padding: 4px;
            border-radius: 3px;
            font-size: 12px;
        }
        .combination-warning {
            padding: 10px 15px;
            background: #f39c12;
            color: #1a1a1a;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 13px;
        }

        @media (max-width: 768px) {
            .tab-btn {
                padding: 10px 16px;
                font-size: 12px;
            }
            .tornado-label {
                width: 100px;
                font-size: 11px;
            }
            .param-selection {
                grid-template-columns: 1fr;
            }
        }

        /* Heatmap */
        .heatmap-container {
            margin: 20px 0;
            padding: 20px;
            background: #1a1a1a;
            border: 1px solid #404040;
            border-radius: 4px;
        }
        .heatmap-controls {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        .heatmap-controls label {
            color: #a0a0a0;
            font-size: 13px;
        }
        .heatmap-controls select {
            background: #2d2d2d;
            border: 1px solid #505050;
            color: #e0e0e0;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
        }
        .heatmap-controls select:hover {
            border-color: #3498db;
        }
        .heatmap-wrapper {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            overflow-x: auto;
        }
        .heatmap-y-label {
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            text-align: center;
            color: #a0a0a0;
            font-size: 12px;
            padding: 10px 5px;
        }
        .heatmap-main {
            display: flex;
            flex-direction: column;
        }
        .heatmap-grid {
            display: flex;
            flex-direction: column;
        }
        .heatmap-row {
            display: flex;
        }
        .heatmap-cell {
            width: 50px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            border: 1px solid #2d2d2d;
            cursor: default;
            transition: transform 0.1s;
        }
        .heatmap-cell:hover {
            transform: scale(1.1);
            z-index: 1;
            box-shadow: 0 0 8px rgba(0,0,0,0.5);
        }
        .heatmap-x-labels {
            display: flex;
            margin-top: 5px;
        }
        .heatmap-x-label {
            width: 50px;
            text-align: center;
            font-size: 11px;
            color: #a0a0a0;
        }
        .heatmap-y-labels {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            margin-right: 5px;
        }
        .heatmap-y-value {
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            font-size: 11px;
            color: #a0a0a0;
            padding-right: 5px;
        }
        .heatmap-x-title {
            text-align: center;
            color: #a0a0a0;
            font-size: 12px;
            margin-top: 8px;
        }
        .heatmap-legend {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            font-size: 12px;
            color: #a0a0a0;
        }
        .heatmap-legend-bar {
            width: 200px;
            height: 16px;
            border-radius: 3px;
            background: linear-gradient(to right, #c0392b, #f39c12, #27ae60);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Venturing Function Dynamics</h1>
        <p class="subtitle">Interactive Simulation of Nested Functional Architecture</p>

        <div class="about-toggle" id="about-toggle" onclick="toggleAbout()">
            <span class="toggle-arrow">&#9654;</span> About
        </div>
        <div class="about-content" id="about-content">
            <h3>What is this?</h3>
            <p>An interactive simulation exploring how ventures emerge through a nested functional architecture with three levels of abstraction.</p>

            <h3>The Three Levels</h3>
            <ul>
                <li><strong>Level 1 &ndash; Framing:</strong> Converts fuzzy (probabilistic) representations of a present situation and an imaginary situation into a crisp binary venture idea using a configurable threshold.</li>
                <li><strong>Level 2 &ndash; Modelling:</strong> Applies an ordering scheme (template) to the raw idea, producing a rigid venture concept with positional constraints.</li>
                <li><strong>Level 3 &ndash; Venturing:</strong> Places the concept into a dynamic binary environment where an agent senses, moves, and flips bits to maximise fit &mdash; yielding success, abandonment (poor fit), or burnout (energy depleted).</li>
            </ul>

            <h3>How to use</h3>
            <ul>
                <li>Adjust sliders to change thresholds, concept size, agent capabilities, and environment parameters.</li>
                <li>Click <em>Generate New Idea</em> and <em>Apply Scheme to Idea</em> to prepare a venture concept.</li>
                <li>Hit <em>Start Venture</em> to watch the agent attempt to fit the concept into the environment in real time.</li>
                <li>Use <em>Single Step</em> to advance one timestep at a time.</li>
            </ul>

            <h3>Built with</h3>
            <p>Pure HTML, CSS, and JavaScript &mdash; no external dependencies.</p>
        </div>

        <div class="tab-nav">
            <button class="tab-btn active" data-tab="simulation" onclick="switchTab('simulation')">Simulation</button>
            <button class="tab-btn" data-tab="cohort" onclick="switchTab('cohort')">Cohort</button>
            <button class="tab-btn" data-tab="sensitivity" onclick="switchTab('sensitivity')">Sensitivity</button>
            <button class="tab-btn" data-tab="experimentation" onclick="switchTab('experimentation')">Experimentation</button>
        </div>

        <div class="tab-content">
            <!-- SIMULATION TAB -->
            <div class="tab-pane active" id="tab-simulation">

        <!-- LEVEL 1: FRAMING -->
        <div class="level-section">
            <div class="level-title">LEVEL 1: FRAMING → Venture Idea</div>
            
            <div class="controls">
                <div class="control-group">
                    <label>Threshold (fuzzy → crisp):</label>
                    <input type="range" id="threshold" min="0" max="100" value="50" step="5">
                    <span id="threshold-val">0.5</span>
                </div>
                <button onclick="generateIdea()">Generate New Idea</button>
            </div>

            <div class="visualization">
                <div>
                    <div style="font-weight: bold; margin-bottom: 5px;">Present Situation (fuzzy)</div>
                    <div id="present-display" class="set-display"></div>
                </div>
                <div class="arrow">+</div>
                <div>
                    <div style="font-weight: bold; margin-bottom: 5px;">Imaginary Situation (fuzzy)</div>
                    <div id="imaginary-display" class="set-display"></div>
                </div>
                <div class="arrow">→</div>
                <div>
                    <div style="font-weight: bold; margin-bottom: 5px;">Venture Idea (crisp)</div>
                    <div id="idea-display" class="set-display"></div>
                </div>
            </div>
        </div>

        <!-- LEVEL 2: MODELLING -->
        <div class="level-section">
            <div class="level-title">LEVEL 2: MODELLING → Venture Concept</div>
            
            <div class="controls">
                <div class="control-group">
                    <label>Concept Size:</label>
                    <input type="range" id="concept-size" min="5" max="15" value="10" step="1">
                    <span id="concept-size-val">10</span>
                </div>
                <button onclick="applySchemeToConcept()">Apply Scheme to Idea</button>
            </div>

            <div class="visualization">
                <div>
                    <div style="font-weight: bold; margin-bottom: 5px;">Venture Idea</div>
                    <div id="idea-for-scheme" class="set-display"></div>
                </div>
                <div class="arrow">+</div>
                <div>
                    <div style="font-weight: bold; margin-bottom: 5px;">Ordering Scheme (template)</div>
                    <div id="scheme-display" class="scheme-template"></div>
                </div>
                <div class="arrow">→</div>
                <div>
                    <div style="font-weight: bold; margin-bottom: 5px;">Venture Concept (ordered & rigid)</div>
                    <div id="concept-display" class="set-display"></div>
                </div>
            </div>
        </div>

        <!-- LEVEL 3: VENTURING -->
        <div class="level-section">
            <div class="level-title">LEVEL 3: VENTURING → Venture Evolution</div>
            
            <div class="controls">
                <h4>Agent Parameters</h4>
                <div class="control-group">
                    <label>Sensing Range:</label>
                    <input type="range" id="sensing-range" min="5" max="30" value="15" step="1">
                    <span id="sensing-range-val">15</span>
                </div>
                <div class="control-group">
                    <label>Flip Power (bits/turn):</label>
                    <input type="range" id="flip-power" min="1" max="5" value="2" step="1">
                    <span id="flip-power-val">2</span>
                </div>
                <div class="control-group">
                    <label>Flip Success Rate:</label>
                    <input type="range" id="flip-rate" min="0" max="100" value="70" step="5">
                    <span id="flip-rate-val">70%</span>
                </div>
                <div class="control-group">
                    <label>Initial Energy:</label>
                    <input type="range" id="energy" min="50" max="300" value="150" step="10">
                    <span id="energy-val">150</span>
                </div>
                <div class="control-group">
                    <label>Abandonment Threshold:</label>
                    <input type="range" id="abandon-threshold" min="20" max="80" value="50" step="5">
                    <span id="abandon-threshold-val">50%</span>
                </div>
                <div class="control-group">
                    <label>Success Threshold:</label>
                    <input type="range" id="success-threshold" min="60" max="100" value="85" step="5">
                    <span id="success-threshold-val">85%</span>
                </div>
                <div class="control-group">
                    <label>Energy Cost per Flip:</label>
                    <input type="range" id="flip-energy-cost" min="0" max="5" value="2" step="1">
                    <span id="flip-energy-cost-val">2</span>
                </div>

                <h4>Environment Parameters</h4>
                <div class="control-group">
                    <label>Environment Size:</label>
                    <input type="range" id="env-size" min="50" max="200" value="100" step="10">
                    <span id="env-size-val">100</span>
                </div>
                <div class="control-group">
                    <label>Environment Flip Rate:</label>
                    <input type="range" id="env-flip-rate" min="0" max="20" value="5" step="1">
                    <span id="env-flip-rate-val">5%</span>
                </div>
                
                <button onclick="startVenture()" id="start-btn">Start Venture</button>
                <button onclick="pauseVenture()" id="pause-btn" disabled>Pause</button>
                <button onclick="resetVenture()" id="reset-btn">Reset</button>
                <button onclick="stepVenture()" id="step-btn">Single Step</button>
            </div>

            <div class="stats">
                <div class="stat-card">
                    <div class="stat-label">Timestep</div>
                    <div class="stat-value" id="timestep">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Energy Remaining</div>
                    <div class="stat-value" id="energy-remaining">150</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Best Fit Score</div>
                    <div class="stat-value" id="fit-score">-</div>
                </div>
                <div class="stat-card" id="outcome-card">
                    <div class="stat-label">Outcome</div>
                    <div class="stat-value" id="outcome">Not Started</div>
                </div>
            </div>

            <div class="environment-display">
                <div style="font-weight: bold; margin-bottom: 10px;">Environment & Concept Window</div>
                <div id="environment-viz"></div>
                <div style="margin-top: 10px; font-size: 12px; color: #a0a0a0;">
                    Orange box = current sensing window | Concept attempting to fit
                </div>
            </div>

            <canvas id="fitness-chart" width="1200" height="300" style="width: 100%; height: auto;"></canvas>
            <div style="font-size: 12px; color: #a0a0a0; margin-top: 5px;">
                Fitness over time (green = good fit, red = poor fit)
            </div>
        </div>

            </div><!-- End tab-simulation -->

            <!-- COHORT TAB -->
            <div class="tab-pane" id="tab-cohort">
        <div class="level-section">
            <div class="level-title">COHORT SIMULATION → Statistical Outcomes</div>

            <div class="controls">
                <div class="control-group">
                    <label>Cohort Size:</label>
                    <input type="range" id="cohort-size" min="10" max="500" value="100" step="10">
                    <span id="cohort-size-val">100</span>
                </div>
                <div class="control-group">
                    <label>Statistical Diffusion:</label>
                    <input type="range" id="cohort-diffusion" min="0" max="100" value="20" step="5">
                    <span id="cohort-diffusion-val">20%</span>
                </div>
                <button onclick="runCohort()" id="cohort-run-btn">Run Cohort</button>
            </div>

            <div class="cohort-progress-container" id="cohort-progress-container">
                <div class="cohort-progress-bar" id="cohort-progress-bar">0%</div>
            </div>

            <div class="stats" id="cohort-stats" style="display: none;">
                <div class="stat-card outcome-success">
                    <div class="stat-label">Success Rate</div>
                    <div class="stat-value" id="cohort-success-rate">-</div>
                </div>
                <div class="stat-card outcome-abandoned">
                    <div class="stat-label">Abandoned Rate</div>
                    <div class="stat-value" id="cohort-abandoned-rate">-</div>
                </div>
                <div class="stat-card outcome-burned-out">
                    <div class="stat-label">Burned Out Rate</div>
                    <div class="stat-value" id="cohort-burned-out-rate">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Avg Final Fitness</div>
                    <div class="stat-value" id="cohort-avg-fitness">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Avg Steps Survived</div>
                    <div class="stat-value" id="cohort-avg-steps">-</div>
                </div>
            </div>

            <canvas id="cohort-chart" width="800" height="300" style="width: 100%; height: auto; display: none;"></canvas>
            <div id="cohort-chart-label" style="font-size: 12px; color: #a0a0a0; margin-top: 5px; display: none;">
                Outcome distribution across cohort agents
            </div>
        </div>
            </div><!-- End tab-cohort -->

            <!-- SENSITIVITY TAB -->
            <div class="tab-pane" id="tab-sensitivity">
        <div class="level-section">
            <div class="level-title">SENSITIVITY ANALYSIS → Parameter Impact</div>

            <div class="controls">
                <div class="control-group">
                    <label>Sample Size (agents per test):</label>
                    <input type="range" id="sensitivity-sample-size" min="20" max="200" value="50" step="10">
                    <span id="sensitivity-sample-size-val">50</span>
                </div>
                <button onclick="runSensitivityAnalysis()" id="sensitivity-run-btn">Run Sensitivity Analysis</button>
            </div>

            <div class="cohort-progress-container" id="sensitivity-progress-container">
                <div class="cohort-progress-bar" id="sensitivity-progress-bar">0%</div>
            </div>

            <div id="sensitivity-results" style="display: none;">
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-label">Baseline Success Rate</div>
                        <div class="stat-value" id="sensitivity-baseline">-</div>
                    </div>
                </div>

                <div class="tornado-container">
                    <div style="font-weight: bold; margin-bottom: 15px; color: #e0e0e0;">Parameter Impact on Success Rate</div>
                    <div id="tornado-chart"></div>
                    <div class="tornado-legend">
                        <div class="tornado-legend-item">
                            <div class="tornado-legend-box" style="background: #3498db;"></div>
                            <span>Low Value</span>
                        </div>
                        <div class="tornado-legend-item">
                            <div class="tornado-legend-box" style="background: #e67e22;"></div>
                            <span>High Value</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
            </div><!-- End tab-sensitivity -->

            <!-- EXPERIMENTATION TAB -->
            <div class="tab-pane" id="tab-experimentation">
        <div class="level-section">
            <div class="level-title">EXPERIMENTATION → Parameter Combinations</div>

            <div class="controls">
                <h4>Select Parameters to Vary</h4>
                <div class="param-selection" id="experiment-param-selection"></div>

                <div class="control-group">
                    <label>Sample Size (agents per combination):</label>
                    <input type="range" id="experiment-sample-size" min="10" max="100" value="30" step="5">
                    <span id="experiment-sample-size-val">30</span>
                </div>

                <div id="combination-warning" class="combination-warning" style="display: none;"></div>

                <button onclick="runExperiments()" id="experiment-run-btn">Run Experiments</button>
            </div>

            <div class="cohort-progress-container" id="experiment-progress-container">
                <div class="cohort-progress-bar" id="experiment-progress-bar">0%</div>
            </div>

            <div id="experiment-results" style="display: none;">
                <div class="heatmap-container" id="heatmap-container" style="display: none;">
                    <div style="font-weight: bold; margin-bottom: 15px; color: #e0e0e0;">Success Rate Heatmap</div>
                    <div class="heatmap-controls">
                        <div>
                            <label>X-Axis: </label>
                            <select id="heatmap-x-axis" onchange="updateHeatmap()"></select>
                        </div>
                        <div>
                            <label>Y-Axis: </label>
                            <select id="heatmap-y-axis" onchange="updateHeatmap()"></select>
                        </div>
                    </div>
                    <div class="heatmap-wrapper">
                        <div class="heatmap-y-label" id="heatmap-y-title"></div>
                        <div class="heatmap-y-labels" id="heatmap-y-labels"></div>
                        <div class="heatmap-main">
                            <div class="heatmap-grid" id="heatmap-grid"></div>
                            <div class="heatmap-x-labels" id="heatmap-x-labels"></div>
                            <div class="heatmap-x-title" id="heatmap-x-title"></div>
                        </div>
                    </div>
                    <div class="heatmap-legend">
                        <span>0%</span>
                        <div class="heatmap-legend-bar"></div>
                        <span>100%</span>
                        <span style="margin-left: 10px; color: #606060;">(Success Rate)</span>
                    </div>
                </div>

                <div class="experiment-table-container">
                    <table class="experiment-table" id="experiment-table">
                        <thead id="experiment-table-head"></thead>
                        <tbody id="experiment-table-body"></tbody>
                    </table>
                </div>
            </div>
        </div>
            </div><!-- End tab-experimentation -->

        </div><!-- End tab-content -->
    </div>

    <script>
        // Global state
        let state = {
            present: [],
            imaginary: [],
            idea: [],
            concept: [],
            environment: [],
            agent: {
                sensingRange: 15,
                flipPower: 2,
                flipRate: 0.7,
                energy: 150,
                abandonThreshold: 0.5
            },
            venture: {
                timestep: 0,
                currentPosition: 0,
                fitnessHistory: [],
                outcome: 'running'
            },
            animationId: null
        };

        // Initialize
        generateIdea();
        applySchemeToConcept();
        initializeEnvironment();
        setupSliders();

        function setupSliders() {
            const sliders = [
                { id: 'threshold', display: 'threshold-val', format: v => (v/100).toFixed(2) },
                { id: 'concept-size', display: 'concept-size-val', format: v => v },
                { id: 'sensing-range', display: 'sensing-range-val', format: v => v },
                { id: 'flip-power', display: 'flip-power-val', format: v => v },
                { id: 'flip-rate', display: 'flip-rate-val', format: v => v + '%' },
                { id: 'energy', display: 'energy-val', format: v => v },
                { id: 'abandon-threshold', display: 'abandon-threshold-val', format: v => v + '%' },
                { id: 'success-threshold', display: 'success-threshold-val', format: v => v + '%' },
                { id: 'flip-energy-cost', display: 'flip-energy-cost-val', format: v => v },
                { id: 'env-size', display: 'env-size-val', format: v => v },
                { id: 'env-flip-rate', display: 'env-flip-rate-val', format: v => v + '%' },
                { id: 'cohort-size', display: 'cohort-size-val', format: v => v },
                { id: 'cohort-diffusion', display: 'cohort-diffusion-val', format: v => v + '%' }
            ];

            sliders.forEach(slider => {
                const element = document.getElementById(slider.id);
                const display = document.getElementById(slider.display);
                element.addEventListener('input', () => {
                    display.textContent = slider.format(element.value);
                });
            });
        }

        function generateIdea() {
            const length = 20;
            const threshold = parseFloat(document.getElementById('threshold').value) / 100;

            // Generate fuzzy sets
            state.present = Array.from({length}, () => Math.random());
            state.imaginary = Array.from({length}, () => Math.random());

            // Combine and crispify (simple averaging + threshold)
            state.idea = state.present.map((p, i) => {
                const combined = (p + state.imaginary[i]) / 2;
                return combined >= threshold ? 1 : 0;
            });

            displayFuzzySets();
            document.getElementById('idea-for-scheme').innerHTML = displayCrispSet(state.idea);
        }

        function displayFuzzySets() {
            document.getElementById('present-display').innerHTML = 
                state.present.map(v => {
                    const intensity = Math.floor(v * 255);
                    return `<span class="fuzzy-bit" style="background: rgb(52, 152, 219, ${v}); color: ${v > 0.5 ? 'white' : 'black'}">${v.toFixed(2)}</span>`;
                }).join('');

            document.getElementById('imaginary-display').innerHTML = 
                state.imaginary.map(v => {
                    const intensity = Math.floor(v * 255);
                    return `<span class="fuzzy-bit" style="background: rgb(231, 76, 60, ${v}); color: ${v > 0.5 ? 'white' : 'black'}">${v.toFixed(2)}</span>`;
                }).join('');

            document.getElementById('idea-display').innerHTML = displayCrispSet(state.idea);
        }

        function displayCrispSet(set) {
            return set.map(bit => 
                `<span class="crisp-bit bit-${bit}">${bit}</span>`
            ).join('');
        }

        function applySchemeToConcept() {
            const conceptSize = parseInt(document.getElementById('concept-size').value);
            
            // Create ordering scheme (template with constraints)
            const scheme = Array(conceptSize).fill(null).map((_, i) => ({
                position: i,
                constraint: i === 0 ? 'must-be-1' : (i === conceptSize - 1 ? 'must-be-0' : 'free')
            }));

            // Display scheme
            document.getElementById('scheme-display').innerHTML = scheme.map((slot, i) => 
                `<div class="scheme-slot">${i+1}</div>`
            ).join('');

            // Apply scheme to idea: extract and order bits according to template
            state.concept = [];
            for (let i = 0; i < conceptSize; i++) {
                const constraint = scheme[i].constraint;
                if (constraint === 'must-be-1') {
                    state.concept.push(1);
                } else if (constraint === 'must-be-0') {
                    state.concept.push(0);
                } else {
                    // Take from idea (with wrapping if idea is shorter)
                    state.concept.push(state.idea[i % state.idea.length]);
                }
            }

            document.getElementById('concept-display').innerHTML = displayCrispSet(state.concept);
        }

        function initializeEnvironment() {
            const envSize = parseInt(document.getElementById('env-size').value);
            state.environment = Array.from({length: envSize}, () => Math.random() > 0.5 ? 1 : 0);
            displayEnvironment();
        }

        function displayEnvironment() {
            const chunkSize = 50;
            const chunks = [];
            for (let i = 0; i < state.environment.length; i += chunkSize) {
                chunks.push(state.environment.slice(i, i + chunkSize));
            }

            document.getElementById('environment-viz').innerHTML = chunks.map((chunk, rowIdx) => 
                `<div class="environment-row">${chunk.map((bit, colIdx) => {
                    const globalIdx = rowIdx * chunkSize + colIdx;
                    const inWindow = globalIdx >= state.venture.currentPosition && 
                                    globalIdx < state.venture.currentPosition + state.concept.length;
                    const style = inWindow ? 'border: 2px solid #e67e22;' : '';
                    return `<span class="crisp-bit bit-${bit}" style="${style}">${bit}</span>`;
                }).join('')}</div>`
            ).join('');
        }

        function calculateFitness(position) {
            if (position + state.concept.length > state.environment.length) {
                return 0; // Out of bounds
            }

            let matches = 0;
            for (let i = 0; i < state.concept.length; i++) {
                if (state.environment[position + i] === state.concept[i]) {
                    matches++;
                }
            }
            return matches / state.concept.length;
        }

        function findBestPosition() {
            const sensingRange = parseInt(document.getElementById('sensing-range').value);
            const startPos = Math.max(0, state.venture.currentPosition - sensingRange);
            const endPos = Math.min(state.environment.length - state.concept.length, 
                                   state.venture.currentPosition + sensingRange);

            let bestPos = state.venture.currentPosition;
            let bestFit = calculateFitness(bestPos);

            for (let pos = startPos; pos <= endPos; pos++) {
                const fit = calculateFitness(pos);
                if (fit > bestFit) {
                    bestFit = fit;
                    bestPos = pos;
                }
            }

            return { position: bestPos, fitness: bestFit };
        }

        function implementAction(position, fitness) {
            // Try to flip environment bits to improve fit
            const flipPower = parseInt(document.getElementById('flip-power').value);
            const flipRate = parseFloat(document.getElementById('flip-rate').value) / 100;
            const flipEnergyCost = parseInt(document.getElementById('flip-energy-cost').value);

            let flipsAttempted = 0;
            for (let i = 0; i < state.concept.length && flipsAttempted < flipPower; i++) {
                const envIdx = position + i;
                if (state.environment[envIdx] !== state.concept[i]) {
                    state.agent.energy -= flipEnergyCost;
                    if (Math.random() < flipRate) {
                        state.environment[envIdx] = state.concept[i];
                    }
                    flipsAttempted++;
                }
            }
        }

        function updateEnvironment() {
            // Random flips in environment
            const flipRate = parseFloat(document.getElementById('env-flip-rate').value) / 100;
            for (let i = 0; i < state.environment.length; i++) {
                if (Math.random() < flipRate) {
                    state.environment[i] = 1 - state.environment[i];
                }
            }
        }

        function stepVenture() {
            if (state.venture.outcome !== 'running') return;

            state.venture.timestep++;

            // Update environment
            updateEnvironment();

            // REGULATION: Find best position
            const { position, fitness } = findBestPosition();
            state.venture.currentPosition = position;

            // IMPLEMENTATION: Try to improve fit
            implementAction(position, fitness);

            // Recalculate fitness after implementation
            const newFitness = calculateFitness(position);
            state.venture.fitnessHistory.push(newFitness);

            // Update energy
            state.agent.energy -= 1;

            // Check outcomes
            const abandonThreshold = parseFloat(document.getElementById('abandon-threshold').value) / 100;
            const successThreshold = parseFloat(document.getElementById('success-threshold').value) / 100;

            if (state.agent.energy <= 0) {
                state.venture.outcome = 'burned-out';
            } else if (newFitness < abandonThreshold && state.venture.timestep > 10) {
                state.venture.outcome = 'abandoned';
            } else if (state.venture.timestep > 50 &&
                      state.venture.fitnessHistory.slice(-20).length >= 20 &&
                      state.venture.fitnessHistory.slice(-20).every(f => f >= successThreshold)) {
                state.venture.outcome = 'success';
            }

            // Update display
            displayEnvironment();
            updateStats();
            drawFitnessChart();

            if (state.venture.outcome !== 'running') {
                pauseVenture();
            }
        }

        function startVenture() {
            if (state.venture.outcome !== 'running') {
                resetVenture();
            }

            document.getElementById('start-btn').disabled = true;
            document.getElementById('pause-btn').disabled = false;

            state.animationId = setInterval(stepVenture, 100);
        }

        function pauseVenture() {
            if (state.animationId) {
                clearInterval(state.animationId);
                state.animationId = null;
            }
            document.getElementById('start-btn').disabled = false;
            document.getElementById('pause-btn').disabled = true;
        }

        function resetVenture() {
            pauseVenture();
            
            state.agent.energy = parseInt(document.getElementById('energy').value);
            state.venture = {
                timestep: 0,
                currentPosition: 0,
                fitnessHistory: [],
                outcome: 'running'
            };

            initializeEnvironment();
            updateStats();
            drawFitnessChart();

            document.getElementById('start-btn').disabled = false;
        }

        function updateStats() {
            document.getElementById('timestep').textContent = state.venture.timestep;
            document.getElementById('energy-remaining').textContent = Math.max(0, state.agent.energy);
            
            const currentFit = state.venture.fitnessHistory.length > 0 ? 
                state.venture.fitnessHistory[state.venture.fitnessHistory.length - 1] : 0;
            document.getElementById('fit-score').textContent = 
                (currentFit * 100).toFixed(1) + '%';

            const outcomeCard = document.getElementById('outcome-card');
            outcomeCard.className = 'stat-card outcome-' + state.venture.outcome;
            
            const outcomeText = {
                'running': 'Running',
                'success': 'SUCCESS ✓',
                'abandoned': 'ABANDONED',
                'burned-out': 'BURNED OUT'
            };
            document.getElementById('outcome').textContent = outcomeText[state.venture.outcome];
        }

        function drawFitnessChart() {
            const canvas = document.getElementById('fitness-chart');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear with dark background
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);

            if (state.venture.fitnessHistory.length === 0) return;

            // Draw grid
            ctx.strokeStyle = '#404040';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = (height / 10) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // Draw fitness line
            const maxSteps = Math.max(100, state.venture.fitnessHistory.length);
            const xScale = width / maxSteps;
            const yScale = height;

            ctx.beginPath();
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;

            state.venture.fitnessHistory.forEach((fitness, i) => {
                const x = i * xScale;
                const y = height - (fitness * yScale);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();

            // Draw abandonment threshold line (red)
            const threshold = parseFloat(document.getElementById('abandon-threshold').value) / 100;
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            const thresholdY = height - (threshold * yScale);
            ctx.beginPath();
            ctx.moveTo(0, thresholdY);
            ctx.lineTo(width, thresholdY);
            ctx.stroke();

            // Draw success threshold line (green)
            const successThreshold = parseFloat(document.getElementById('success-threshold').value) / 100;
            ctx.strokeStyle = '#27ae60';
            const successY = height - (successThreshold * yScale);
            ctx.beginPath();
            ctx.moveTo(0, successY);
            ctx.lineTo(width, successY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw labels with light color
            ctx.fillStyle = '#a0a0a0';
            ctx.font = '12px Arial';
            ctx.fillText('0%', 5, height - 5);
            ctx.fillText('100%', 5, 15);
            ctx.fillStyle = '#e74c3c';
            ctx.fillText(`Fail: ${(threshold*100).toFixed(0)}%`, width - 120, thresholdY + 14);
            ctx.fillStyle = '#27ae60';
            ctx.fillText(`Success: ${(successThreshold*100).toFixed(0)}%`, width - 120, successY - 5);
        }

        function toggleAbout() {
            document.getElementById('about-toggle').classList.toggle('open');
            document.getElementById('about-content').classList.toggle('open');
        }

        // Initial draw
        drawFitnessChart();

        // --- Cohort Simulation ---

        function gaussianRandom(mean, stddev) {
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            return mean + z * stddev;
        }

        function generateAgentParams(diffusion) {
            const sliderDefs = [
                { id: 'sensing-range',      min: 5,  max: 30,  round: true },
                { id: 'flip-power',         min: 1,  max: 5,   round: true },
                { id: 'flip-rate',          min: 0,  max: 100, round: false },
                { id: 'energy',             min: 50, max: 300, round: true },
                { id: 'abandon-threshold',  min: 20, max: 80,  round: false },
                { id: 'success-threshold',  min: 60, max: 100, round: false },
                { id: 'flip-energy-cost',   min: 0,  max: 5,   round: true },
                { id: 'env-size',           min: 50, max: 200, round: true },
                { id: 'env-flip-rate',      min: 0,  max: 20,  round: false }
            ];

            const params = {};
            sliderDefs.forEach(def => {
                const baseVal = parseFloat(document.getElementById(def.id).value);
                const range = def.max - def.min;
                const stddev = diffusion * range / 4;
                let val = gaussianRandom(baseVal, stddev);
                val = Math.max(def.min, Math.min(def.max, val));
                if (def.round) val = Math.round(val);
                params[def.id] = val;
            });
            return params;
        }

        function simulateOneAgent(params, concept) {
            const MAX_STEPS = 1000;
            const envSize = params['env-size'];
            const env = Array.from({ length: envSize }, () => Math.random() > 0.5 ? 1 : 0);
            let energy = params['energy'];
            let currentPosition = 0;
            const fitnessHistory = [];
            let outcome = 'running';
            let timestep = 0;

            const sensingRange = params['sensing-range'];
            const flipPower = params['flip-power'];
            const flipRate = params['flip-rate'] / 100;
            const flipEnergyCost = params['flip-energy-cost'];
            const abandonThreshold = params['abandon-threshold'] / 100;
            const successThreshold = params['success-threshold'] / 100;
            const envFlipRate = params['env-flip-rate'] / 100;

            function calcFitness(pos) {
                if (pos + concept.length > env.length) return 0;
                let matches = 0;
                for (let i = 0; i < concept.length; i++) {
                    if (env[pos + i] === concept[i]) matches++;
                }
                return matches / concept.length;
            }

            while (outcome === 'running' && timestep < MAX_STEPS) {
                timestep++;

                // Environment flips
                for (let i = 0; i < env.length; i++) {
                    if (Math.random() < envFlipRate) env[i] = 1 - env[i];
                }

                // Find best position (regulation)
                const startPos = Math.max(0, currentPosition - sensingRange);
                const endPos = Math.min(env.length - concept.length, currentPosition + sensingRange);
                let bestPos = currentPosition;
                let bestFit = calcFitness(bestPos);
                for (let pos = startPos; pos <= endPos; pos++) {
                    const fit = calcFitness(pos);
                    if (fit > bestFit) {
                        bestFit = fit;
                        bestPos = pos;
                    }
                }
                currentPosition = bestPos;

                // Implementation: flip bits
                let flipsAttempted = 0;
                for (let i = 0; i < concept.length && flipsAttempted < flipPower; i++) {
                    const envIdx = currentPosition + i;
                    if (env[envIdx] !== concept[i]) {
                        energy -= flipEnergyCost;
                        if (Math.random() < flipRate) env[envIdx] = concept[i];
                        flipsAttempted++;
                    }
                }

                // Recalculate fitness
                const newFitness = calcFitness(currentPosition);
                fitnessHistory.push(newFitness);

                // Energy drain
                energy -= 1;

                // Check outcomes
                if (energy <= 0) {
                    outcome = 'burned-out';
                } else if (newFitness < abandonThreshold && timestep > 10) {
                    outcome = 'abandoned';
                } else if (
                    timestep > 50 &&
                    fitnessHistory.length >= 20 &&
                    fitnessHistory.slice(-20).every(f => f >= successThreshold)
                ) {
                    outcome = 'success';
                }
            }

            // If still running after MAX_STEPS, count as burned out
            if (outcome === 'running') outcome = 'burned-out';

            const finalFitness = fitnessHistory.length > 0 ? fitnessHistory[fitnessHistory.length - 1] : 0;
            return { outcome, steps: timestep, finalFitness };
        }

        function runCohort() {
            const cohortSize = parseInt(document.getElementById('cohort-size').value);
            const diffusion = parseFloat(document.getElementById('cohort-diffusion').value) / 100;
            const conceptSnapshot = state.concept.slice();

            if (conceptSnapshot.length === 0) {
                alert('Generate an idea and apply a scheme first (Levels 1 & 2).');
                return;
            }

            const btn = document.getElementById('cohort-run-btn');
            btn.disabled = true;

            const progressContainer = document.getElementById('cohort-progress-container');
            const progressBar = document.getElementById('cohort-progress-bar');
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';

            document.getElementById('cohort-stats').style.display = 'none';
            document.getElementById('cohort-chart').style.display = 'none';
            document.getElementById('cohort-chart-label').style.display = 'none';

            const results = [];
            let completed = 0;
            const CHUNK = 10;

            function processChunk() {
                const end = Math.min(completed + CHUNK, cohortSize);
                for (let i = completed; i < end; i++) {
                    const params = generateAgentParams(diffusion);
                    results.push(simulateOneAgent(params, conceptSnapshot));
                }
                completed = end;

                const pct = Math.round((completed / cohortSize) * 100);
                progressBar.style.width = pct + '%';
                progressBar.textContent = pct + '%';

                if (completed < cohortSize) {
                    setTimeout(processChunk, 0);
                } else {
                    btn.disabled = false;
                    displayCohortResults(results);
                }
            }

            setTimeout(processChunk, 0);
        }

        function displayCohortResults(results) {
            const total = results.length;
            const counts = { success: 0, abandoned: 0, 'burned-out': 0 };
            let totalFitness = 0;
            let totalSteps = 0;

            results.forEach(r => {
                counts[r.outcome]++;
                totalFitness += r.finalFitness;
                totalSteps += r.steps;
            });

            document.getElementById('cohort-success-rate').textContent =
                (counts.success / total * 100).toFixed(1) + '%';
            document.getElementById('cohort-abandoned-rate').textContent =
                (counts.abandoned / total * 100).toFixed(1) + '%';
            document.getElementById('cohort-burned-out-rate').textContent =
                (counts['burned-out'] / total * 100).toFixed(1) + '%';
            document.getElementById('cohort-avg-fitness').textContent =
                (totalFitness / total * 100).toFixed(1) + '%';
            document.getElementById('cohort-avg-steps').textContent =
                (totalSteps / total).toFixed(1);

            document.getElementById('cohort-stats').style.display = 'grid';
            drawCohortChart(counts, total);
        }

        function drawCohortChart(counts, total) {
            const canvas = document.getElementById('cohort-chart');
            canvas.style.display = 'block';
            document.getElementById('cohort-chart-label').style.display = 'block';

            const ctx = canvas.getContext('2d');
            const W = canvas.width;
            const H = canvas.height;

            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, W, H);

            const categories = [
                { key: 'success',    label: 'Success',    color: '#27ae60' },
                { key: 'abandoned',  label: 'Abandoned',  color: '#7f8c8d' },
                { key: 'burned-out', label: 'Burned Out', color: '#8e44ad' }
            ];

            const padding = { left: 60, right: 40, top: 30, bottom: 50 };
            const chartW = W - padding.left - padding.right;
            const chartH = H - padding.top - padding.bottom;
            const barWidth = chartW / categories.length * 0.6;
            const gap = chartW / categories.length;

            // Y-axis gridlines (0% to 100%)
            ctx.strokeStyle = '#404040';
            ctx.lineWidth = 1;
            ctx.fillStyle = '#a0a0a0';
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const pct = i * 20;
                const y = padding.top + chartH - (pct / 100) * chartH;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(W - padding.right, y);
                ctx.stroke();
                ctx.fillText(pct + '%', padding.left - 8, y + 4);
            }

            // Bars
            categories.forEach((cat, idx) => {
                const pct = total > 0 ? counts[cat.key] / total : 0;
                const barH = pct * chartH;
                const x = padding.left + idx * gap + (gap - barWidth) / 2;
                const y = padding.top + chartH - barH;

                ctx.fillStyle = cat.color;
                ctx.fillRect(x, y, barWidth, barH);

                // Percentage label above bar
                ctx.fillStyle = '#e0e0e0';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText((pct * 100).toFixed(1) + '%', x + barWidth / 2, y - 8);

                // Category label below bar
                ctx.fillStyle = '#a0a0a0';
                ctx.font = '13px Arial';
                ctx.fillText(cat.label, x + barWidth / 2, padding.top + chartH + 20);

                // Count below label
                ctx.fillStyle = '#808080';
                ctx.font = '11px Arial';
                ctx.fillText('(' + counts[cat.key] + '/' + total + ')', x + barWidth / 2, padding.top + chartH + 38);
            });
        }

        // --- Tab Navigation ---

        function switchTab(tabId) {
            document.querySelectorAll('.tab-btn').forEach(btn =>
                btn.classList.toggle('active', btn.dataset.tab === tabId));
            document.querySelectorAll('.tab-pane').forEach(pane =>
                pane.classList.toggle('active', pane.id === 'tab-' + tabId));
        }

        // --- Sensitivity Analysis ---

        const sensitivityParams = [
            { id: 'sensing-range',     label: 'Sensing Range',      min: 5,  max: 30,  round: true },
            { id: 'flip-power',        label: 'Flip Power',         min: 1,  max: 5,   round: true },
            { id: 'flip-rate',         label: 'Flip Success Rate',  min: 0,  max: 100, round: false },
            { id: 'energy',            label: 'Initial Energy',     min: 50, max: 300, round: true },
            { id: 'abandon-threshold', label: 'Abandon Threshold',  min: 20, max: 80,  round: false },
            { id: 'success-threshold', label: 'Success Threshold',  min: 60, max: 100, round: false },
            { id: 'flip-energy-cost',  label: 'Flip Energy Cost',   min: 0,  max: 5,   round: true },
            { id: 'env-size',          label: 'Environment Size',   min: 50, max: 200, round: true },
            { id: 'env-flip-rate',     label: 'Env Flip Rate',      min: 0,  max: 20,  round: false }
        ];

        function getBaselineParams() {
            const params = {};
            sensitivityParams.forEach(p => {
                params[p.id] = parseFloat(document.getElementById(p.id).value);
            });
            return params;
        }

        function runCohortWithParams(params, sampleSize, concept) {
            let successes = 0;
            let totalFitness = 0;
            let totalSteps = 0;

            for (let i = 0; i < sampleSize; i++) {
                const result = simulateOneAgent(params, concept);
                if (result.outcome === 'success') successes++;
                totalFitness += result.finalFitness;
                totalSteps += result.steps;
            }

            return {
                successRate: successes / sampleSize,
                avgFitness: totalFitness / sampleSize,
                avgSteps: totalSteps / sampleSize
            };
        }

        function runSensitivityAnalysis() {
            const sampleSize = parseInt(document.getElementById('sensitivity-sample-size').value);
            const conceptSnapshot = state.concept.slice();

            if (conceptSnapshot.length === 0) {
                alert('Generate an idea and apply a scheme first (Levels 1 & 2 in Simulation tab).');
                return;
            }

            const btn = document.getElementById('sensitivity-run-btn');
            btn.disabled = true;

            const progressContainer = document.getElementById('sensitivity-progress-container');
            const progressBar = document.getElementById('sensitivity-progress-bar');
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';

            document.getElementById('sensitivity-results').style.display = 'none';

            const baselineParams = getBaselineParams();
            const totalTests = 1 + sensitivityParams.length * 2; // baseline + low/high for each param
            let testsCompleted = 0;

            const results = [];
            let baselineResult = null;

            function updateProgress() {
                const pct = Math.round((testsCompleted / totalTests) * 100);
                progressBar.style.width = pct + '%';
                progressBar.textContent = pct + '%';
            }

            function runNextTest() {
                if (testsCompleted === 0) {
                    // Run baseline
                    baselineResult = runCohortWithParams(baselineParams, sampleSize, conceptSnapshot);
                    testsCompleted++;
                    updateProgress();
                    setTimeout(runNextTest, 0);
                } else if (testsCompleted <= sensitivityParams.length * 2) {
                    const paramIdx = Math.floor((testsCompleted - 1) / 2);
                    const isLow = (testsCompleted - 1) % 2 === 0;
                    const param = sensitivityParams[paramIdx];

                    const testParams = { ...baselineParams };
                    testParams[param.id] = isLow ? param.min : param.max;

                    const result = runCohortWithParams(testParams, sampleSize, conceptSnapshot);

                    if (isLow) {
                        results.push({
                            param: param,
                            lowValue: param.min,
                            highValue: param.max,
                            lowResult: result,
                            highResult: null
                        });
                    } else {
                        results[results.length - 1].highResult = result;
                    }

                    testsCompleted++;
                    updateProgress();
                    setTimeout(runNextTest, 0);
                } else {
                    // Done
                    btn.disabled = false;
                    displaySensitivityResults(baselineResult, results);
                }
            }

            setTimeout(runNextTest, 0);
        }

        function displaySensitivityResults(baseline, results) {
            document.getElementById('sensitivity-results').style.display = 'block';
            document.getElementById('sensitivity-baseline').textContent =
                (baseline.successRate * 100).toFixed(1) + '%';

            // Calculate impact and sort by absolute range
            results.forEach(r => {
                r.lowDelta = r.lowResult.successRate - baseline.successRate;
                r.highDelta = r.highResult.successRate - baseline.successRate;
                r.range = Math.abs(r.highDelta - r.lowDelta);
            });

            results.sort((a, b) => b.range - a.range);

            drawTornadoChart(results, baseline.successRate);
        }

        function drawTornadoChart(results, baselineRate) {
            const container = document.getElementById('tornado-chart');

            // Find max absolute delta for scaling
            let maxDelta = 0;
            results.forEach(r => {
                maxDelta = Math.max(maxDelta, Math.abs(r.lowDelta), Math.abs(r.highDelta));
            });
            if (maxDelta < 0.01) maxDelta = 0.01; // Prevent division by zero

            let html = '';
            results.forEach(r => {
                const lowWidth = Math.abs(r.lowDelta) / maxDelta * 45; // 45% max width each side
                const highWidth = Math.abs(r.highDelta) / maxDelta * 45;

                // Low bar: extends left if negative delta, right if positive
                let lowStyle, highStyle;
                if (r.lowDelta < 0) {
                    lowStyle = `right: 50%; width: ${lowWidth}%;`;
                } else {
                    lowStyle = `left: 50%; width: ${lowWidth}%;`;
                }
                if (r.highDelta < 0) {
                    highStyle = `right: 50%; width: ${highWidth}%;`;
                } else {
                    highStyle = `left: 50%; width: ${highWidth}%;`;
                }

                html += `
                    <div class="tornado-row">
                        <div class="tornado-label">${r.param.label}</div>
                        <div class="tornado-bar-container">
                            <div class="tornado-center-line"></div>
                            <div class="tornado-bar low" style="${lowStyle}"
                                 title="Low (${r.lowValue}): ${(r.lowDelta * 100).toFixed(1)}%"></div>
                            <div class="tornado-bar high" style="${highStyle}"
                                 title="High (${r.highValue}): ${(r.highDelta * 100).toFixed(1)}%"></div>
                        </div>
                        <div class="tornado-value">${(r.range * 100).toFixed(1)}%</div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // --- Experimentation ---

        const experimentParams = sensitivityParams.map(p => ({
            ...p,
            selected: false,
            minVal: p.min,
            maxVal: p.max,
            steps: 3
        }));

        let experimentResults = [];
        let experimentSortColumn = null;
        let experimentSortAsc = true;

        function initExperimentParamSelection() {
            const container = document.getElementById('experiment-param-selection');
            let html = '';

            experimentParams.forEach((p, idx) => {
                html += `
                    <div class="param-checkbox-group" id="param-group-${idx}">
                        <label class="param-checkbox-label">
                            <input type="checkbox" onchange="toggleExperimentParam(${idx}, this.checked)">
                            ${p.label}
                        </label>
                        <div class="param-range-inputs">
                            <div>
                                <label>Min:</label>
                                <input type="number" id="exp-min-${idx}" value="${p.min}" min="${p.min}" max="${p.max}" oninput="updateExperimentParam(${idx})">
                            </div>
                            <div>
                                <label>Max:</label>
                                <input type="number" id="exp-max-${idx}" value="${p.max}" min="${p.min}" max="${p.max}" oninput="updateExperimentParam(${idx})">
                            </div>
                            <div>
                                <label>Steps:</label>
                                <input type="number" id="exp-steps-${idx}" value="3" min="2" max="10" oninput="updateExperimentParam(${idx})">
                            </div>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function toggleExperimentParam(idx, selected) {
            experimentParams[idx].selected = selected;
            const group = document.getElementById('param-group-' + idx);
            group.classList.toggle('selected', selected);
            updateCombinationCount();
        }

        function updateExperimentParam(idx) {
            // Just trigger a combination count update which syncs all params
            updateCombinationCount();
        }

        function syncAllExperimentParams() {
            // Read current values from all input fields to ensure experimentParams is up-to-date
            experimentParams.forEach((p, idx) => {
                const minEl = document.getElementById('exp-min-' + idx);
                const maxEl = document.getElementById('exp-max-' + idx);
                const stepsEl = document.getElementById('exp-steps-' + idx);

                if (minEl && maxEl && stepsEl) {
                    const minInput = parseFloat(minEl.value);
                    const maxInput = parseFloat(maxEl.value);
                    const stepsInput = parseInt(stepsEl.value);

                    p.minVal = isNaN(minInput) ? p.min : minInput;
                    p.maxVal = isNaN(maxInput) ? p.max : maxInput;
                    p.steps = isNaN(stepsInput) || stepsInput < 2 ? 3 : stepsInput;

                    // Clamp to valid range
                    p.minVal = Math.max(p.min, Math.min(p.max, p.minVal));
                    p.maxVal = Math.max(p.min, Math.min(p.max, p.maxVal));

                    // Ensure min <= max
                    if (p.minVal > p.maxVal) {
                        const temp = p.minVal;
                        p.minVal = p.maxVal;
                        p.maxVal = temp;
                    }
                }
            });
        }

        function updateCombinationCount() {
            syncAllExperimentParams();
            const selected = experimentParams.filter(p => p.selected);
            if (selected.length === 0) {
                document.getElementById('combination-warning').style.display = 'none';
                return;
            }

            let combinations = 1;
            selected.forEach(p => combinations *= p.steps);

            const warning = document.getElementById('combination-warning');
            if (combinations > 100) {
                warning.style.display = 'block';
                warning.style.background = '#f39c12';
                warning.textContent = `Warning: ${combinations} combinations selected. This may take a while. Consider reducing steps or parameters (max recommended: 100).`;
            } else {
                warning.style.display = 'block';
                warning.style.background = '#27ae60';
                warning.textContent = `${combinations} combinations will be tested.`;
            }
        }

        function generateCombinations(selectedParams, baselineParams) {
            const combinations = [];

            function recurse(idx, currentCombo) {
                if (idx >= selectedParams.length) {
                    combinations.push({ ...currentCombo });
                    return;
                }

                const p = selectedParams[idx];
                const stepSize = (p.maxVal - p.minVal) / (p.steps - 1);

                for (let i = 0; i < p.steps; i++) {
                    let val = p.minVal + stepSize * i;
                    if (p.round) val = Math.round(val);
                    currentCombo[p.id] = val;
                    recurse(idx + 1, currentCombo);
                }
            }

            recurse(0, { ...baselineParams });
            return combinations;
        }

        function runExperiments() {
            const sampleSize = parseInt(document.getElementById('experiment-sample-size').value);
            const conceptSnapshot = state.concept.slice();

            if (conceptSnapshot.length === 0) {
                alert('Generate an idea and apply a scheme first (Levels 1 & 2 in Simulation tab).');
                return;
            }

            // Sync all parameter values from inputs before running
            syncAllExperimentParams();

            const selectedParams = experimentParams.filter(p => p.selected);
            if (selectedParams.length === 0) {
                alert('Select at least one parameter to vary.');
                return;
            }

            const baselineParams = getBaselineParams();
            const combinations = generateCombinations(selectedParams, baselineParams);

            if (combinations.length > 500) {
                if (!confirm(`This will run ${combinations.length} simulations. Continue?`)) {
                    return;
                }
            }

            const btn = document.getElementById('experiment-run-btn');
            btn.disabled = true;

            const progressContainer = document.getElementById('experiment-progress-container');
            const progressBar = document.getElementById('experiment-progress-bar');
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';

            document.getElementById('experiment-results').style.display = 'none';

            experimentResults = [];
            let completed = 0;

            function processNext() {
                if (completed >= combinations.length) {
                    btn.disabled = false;
                    displayExperimentResults(selectedParams);
                    return;
                }

                const params = combinations[completed];
                const result = runCohortWithParams(params, sampleSize, conceptSnapshot);

                experimentResults.push({
                    params: params,
                    successRate: result.successRate,
                    failureRate: 0, // Would need to track this in runCohortWithParams
                    abandonedRate: 0,
                    avgFitness: result.avgFitness,
                    avgSteps: result.avgSteps
                });

                completed++;
                const pct = Math.round((completed / combinations.length) * 100);
                progressBar.style.width = pct + '%';
                progressBar.textContent = pct + '%';

                setTimeout(processNext, 0);
            }

            setTimeout(processNext, 0);
        }

        // Store selected params for heatmap
        let heatmapSelectedParams = [];

        function displayExperimentResults(selectedParams) {
            document.getElementById('experiment-results').style.display = 'block';
            heatmapSelectedParams = selectedParams;

            const thead = document.getElementById('experiment-table-head');
            const tbody = document.getElementById('experiment-table-body');

            // Build header
            let headerHtml = '<tr>';
            selectedParams.forEach(p => {
                headerHtml += `<th onclick="sortExperimentTable('${p.id}')">${p.label}<span class="sort-indicator">▼</span></th>`;
            });
            headerHtml += '<th onclick="sortExperimentTable(\'successRate\')">Success Rate<span class="sort-indicator">▼</span></th>';
            headerHtml += '<th onclick="sortExperimentTable(\'avgFitness\')">Avg Fitness<span class="sort-indicator">▼</span></th>';
            headerHtml += '<th onclick="sortExperimentTable(\'avgSteps\')">Avg Steps<span class="sort-indicator">▼</span></th>';
            headerHtml += '</tr>';
            thead.innerHTML = headerHtml;

            renderExperimentTableBody(selectedParams);

            // Setup heatmap if 2+ parameters
            setupHeatmap(selectedParams);
        }

        function setupHeatmap(selectedParams) {
            const container = document.getElementById('heatmap-container');

            if (selectedParams.length < 2) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';

            // Populate axis dropdowns
            const xSelect = document.getElementById('heatmap-x-axis');
            const ySelect = document.getElementById('heatmap-y-axis');

            let optionsHtml = '';
            selectedParams.forEach(p => {
                optionsHtml += `<option value="${p.id}">${p.label}</option>`;
            });

            xSelect.innerHTML = optionsHtml;
            ySelect.innerHTML = optionsHtml;

            // Default: first param on X, second on Y
            xSelect.value = selectedParams[0].id;
            ySelect.value = selectedParams[1].id;

            updateHeatmap();
        }

        function updateHeatmap() {
            const xParamId = document.getElementById('heatmap-x-axis').value;
            const yParamId = document.getElementById('heatmap-y-axis').value;

            if (xParamId === yParamId) {
                // Same axis selected, swap Y to a different one
                const other = heatmapSelectedParams.find(p => p.id !== xParamId);
                if (other) {
                    document.getElementById('heatmap-y-axis').value = other.id;
                    return updateHeatmap();
                }
            }

            const xParam = heatmapSelectedParams.find(p => p.id === xParamId);
            const yParam = heatmapSelectedParams.find(p => p.id === yParamId);

            if (!xParam || !yParam) return;

            // Get unique values for each axis from the results
            const xValues = [...new Set(experimentResults.map(r => r.params[xParamId]))].sort((a, b) => a - b);
            const yValues = [...new Set(experimentResults.map(r => r.params[yParamId]))].sort((a, b) => b - a); // Reversed for display

            // Build a map of (x, y) -> average success rate
            const successMap = {};
            const countMap = {};

            experimentResults.forEach(r => {
                const x = r.params[xParamId];
                const y = r.params[yParamId];
                const key = `${x}_${y}`;

                if (!successMap[key]) {
                    successMap[key] = 0;
                    countMap[key] = 0;
                }
                successMap[key] += r.successRate;
                countMap[key]++;
            });

            // Average the success rates
            Object.keys(successMap).forEach(key => {
                successMap[key] /= countMap[key];
            });

            // Render the heatmap grid
            const gridEl = document.getElementById('heatmap-grid');
            const xLabelsEl = document.getElementById('heatmap-x-labels');
            const yLabelsEl = document.getElementById('heatmap-y-labels');

            let gridHtml = '';
            yValues.forEach(y => {
                gridHtml += '<div class="heatmap-row">';
                xValues.forEach(x => {
                    const key = `${x}_${y}`;
                    const rate = successMap[key];
                    const color = getHeatmapColor(rate);
                    const textColor = rate > 0.5 ? '#000' : '#fff';
                    const displayRate = rate !== undefined ? (rate * 100).toFixed(0) + '%' : '-';
                    gridHtml += `<div class="heatmap-cell" style="background: ${color}; color: ${textColor};" title="${xParam.label}=${x}, ${yParam.label}=${y}: ${displayRate}">${displayRate}</div>`;
                });
                gridHtml += '</div>';
            });
            gridEl.innerHTML = gridHtml;

            // X-axis labels
            let xLabelsHtml = '';
            xValues.forEach(x => {
                xLabelsHtml += `<div class="heatmap-x-label">${x}</div>`;
            });
            xLabelsEl.innerHTML = xLabelsHtml;

            // Y-axis labels
            let yLabelsHtml = '';
            yValues.forEach(y => {
                yLabelsHtml += `<div class="heatmap-y-value">${y}</div>`;
            });
            yLabelsEl.innerHTML = yLabelsHtml;

            // Axis titles
            document.getElementById('heatmap-x-title').textContent = xParam.label;
            document.getElementById('heatmap-y-title').textContent = yParam.label;
        }

        function getHeatmapColor(rate) {
            if (rate === undefined) return '#404040';

            // Interpolate from red (0%) -> yellow (50%) -> green (100%)
            let r, g, b;
            if (rate < 0.5) {
                // Red to Yellow
                const t = rate * 2;
                r = 192;
                g = Math.round(57 + t * (156 - 57));
                b = Math.round(43 + t * (18 - 43));
            } else {
                // Yellow to Green
                const t = (rate - 0.5) * 2;
                r = Math.round(243 - t * (243 - 39));
                g = Math.round(156 + t * (174 - 156));
                b = Math.round(18 + t * (96 - 18));
            }
            return `rgb(${r}, ${g}, ${b})`;
        }

        function renderExperimentTableBody(selectedParams) {
            if (!selectedParams) {
                selectedParams = experimentParams.filter(p => p.selected);
            }

            const tbody = document.getElementById('experiment-table-body');
            let bodyHtml = '';

            experimentResults.forEach(r => {
                bodyHtml += '<tr>';
                selectedParams.forEach(p => {
                    bodyHtml += `<td>${r.params[p.id]}</td>`;
                });
                bodyHtml += `<td>${(r.successRate * 100).toFixed(1)}%</td>`;
                bodyHtml += `<td>${(r.avgFitness * 100).toFixed(1)}%</td>`;
                bodyHtml += `<td>${r.avgSteps.toFixed(1)}</td>`;
                bodyHtml += '</tr>';
            });

            tbody.innerHTML = bodyHtml;
        }

        function sortExperimentTable(column) {
            if (experimentSortColumn === column) {
                experimentSortAsc = !experimentSortAsc;
            } else {
                experimentSortColumn = column;
                experimentSortAsc = true;
            }

            experimentResults.sort((a, b) => {
                let valA, valB;
                if (column === 'successRate' || column === 'avgFitness' || column === 'avgSteps') {
                    valA = a[column];
                    valB = b[column];
                } else {
                    valA = a.params[column];
                    valB = b.params[column];
                }

                if (valA < valB) return experimentSortAsc ? -1 : 1;
                if (valA > valB) return experimentSortAsc ? 1 : -1;
                return 0;
            });

            renderExperimentTableBody();
        }

        // Setup additional slider listeners
        function setupAdditionalSliders() {
            const additionalSliders = [
                { id: 'sensitivity-sample-size', display: 'sensitivity-sample-size-val', format: v => v },
                { id: 'experiment-sample-size', display: 'experiment-sample-size-val', format: v => v }
            ];

            additionalSliders.forEach(slider => {
                const element = document.getElementById(slider.id);
                const display = document.getElementById(slider.display);
                if (element && display) {
                    element.addEventListener('input', () => {
                        display.textContent = slider.format(element.value);
                    });
                }
            });
        }

        // Initialize experiment parameter selection
        initExperimentParamSelection();
        setupAdditionalSliders();
    </script>
</body>
</html>
